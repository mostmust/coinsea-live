<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>김치프리미엄 계산기</title>
  <style>
    body {
      font-family: 'Nanum Gothic', sans-serif;
      background-color: #f8f8f8;
      margin: 0;
      padding: 30px;
      text-align: center;
    }
    h1 {
      font-size: 24px;
      margin-bottom: 5px;
    }
    .subtitle {
      font-size: 14px;
      color: #666;
      margin-bottom: 20px;
    }
    table {
      margin: 0 auto;
      border-collapse: collapse;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      min-width: 90%;
      max-width: 960px;
    }
    th, td {
      padding: 10px 12px;
      border: 1px solid #ddd;
    }
    th {
      background-color: #eee;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .updated-time {
      font-size: 13px;
      color: #444;
    }
  </style>
</head>
<body>
  <h1>업비트 vs 바이낸스 김치프리미엄</h1>
  <div class="subtitle">
    <div id="update-time" class="updated-time">⏱ 마지막 업데이트: -</div>
    <div class="updated-time">🔄 30초마다 자동 업데이트됩니다.</div>
  </div>

  <table>
    <thead>
      <tr>
        <th>코인</th>
        <th>업비트 (KRW)</th>
        <th>바이낸스 (USD)</th>
        <th>환율 (KRW)</th>
        <th>바이낸스 (KRW 환산)</th>
        <th>김프 (%)</th>
      </tr>
    </thead>
    <tbody id="table-body">
      <!-- 데이터가 여기에 표시됨 -->
    </tbody>
  </table>

  <script>
    const coins = [
      'BTC','ETH','XRP','ADA','SOL','DOGE','DOT','AVAX','TRX','BCH',
      'LINK','LTC','MATIC','ETC','XLM','SAND','EOS','APT','ATOM','NEAR',
      'AAVE','STX','IMX','ZIL','WAVES','CHZ','FTM','ARPA','RUNE','GALA'
    ];

    async function fetchExchangeRate() {
      try {
        const res = await fetch("/.netlify/functions/exchangeRate");
        const json = await res.json();
        return json.usdToKrw;
      } catch (e) {
        return null;
      }
    }

    async function fetchBinancePrice(symbol) {
      try {
        const res = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}USDT`);
        const json = await res.json();
        return parseFloat(json.price);
      } catch (e) {
        return null;
      }
    }

    async function fetchUpbitPrice(symbol) {
      try {
        const res = await fetch(`https://corsproxy.io/?https://api.upbit.com/v1/ticker?markets=KRW-${symbol}`);
        const json = await res.json();
        return json[0].trade_price;
      } catch (e) {
        return null;
      }
    }

    function updateTimeText() {
      const now = new Date();
      const formatted = now.toLocaleString("ko-KR", {
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit"
      });
      document.getElementById('update-time').textContent = `⏱ 마지막 업데이트: ${formatted}`;
    }

    async function updateTable() {
      const tbody = document.getElementById("table-body");
      tbody.innerHTML = "";
      updateTimeText();

      const exchangeRate = await fetchExchangeRate();
      if (!exchangeRate) {
        tbody.innerHTML = `<tr><td colspan="6" class="error">❌ 환율 불러오기 실패</td></tr>`;
        return;
      }

      for (const coin of coins) {
        const [upbit, binance] = await Promise.all([
          fetchUpbitPrice(coin),
          fetchBinancePrice(coin)
        ]);

        let row = "<tr>";
        row += `<td>${coin}</td>`;

        if (upbit && binance) {
          const binanceToKrw = binance * exchangeRate;
          const kimchi = ((upbit - binanceToKrw) / binanceToKrw) * 100;

          row += `<td>${upbit.toLocaleString()} KRW</td>`;
          row += `<td>${binance.toLocaleString()} USD</td>`;
          row += `<td>${exchangeRate.toLocaleString()} KRW</td>`;
          row += `<td>${binanceToKrw.toLocaleString()} KRW</td>`;
          row += `<td>${kimchi.toFixed(2)}%</td>`;
        } else {
          row += `<td colspan="5" class="error">❌ 데이터 로딩 실패</td>`;
        }

        row += "</tr>";
        tbody.innerHTML += row;
      }
    }

    updateTable();
    setInterval(updateTable, 30000);
  </script>
</body>
</html>
